<!-- ---
icon: octicons/person-16
--- -->

# Client-side SDK

Colyseus currently has official client-side SDKs for the following platforms:

<div class="grid cards" markdown>

- [**:fontawesome-brands-js: JavaScript/TypeScript**](/getting-started/javascript-client)
- [**:fontawesome-brands-unity: Unity**](/getting-started/unity-sdk)
- [**<svg width="16" height="16" viewBox="0 0 312 300" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"> <g transform="matrix(1,0,0,1,-144,-217)"> <g transform="matrix(1,0,0,1,450.739,342.143)"> <path d="M0,49.714L-51.123,20.319L-51.123,79.109L-96.985,52.739L-96.985,-6.051L-148.109,-35.446L-148.109,-88.186L-96.986,-58.791L-96.985,-117.581L-51.123,-91.211L-51.123,-32.421L0,-3.026L0,49.714ZM-51.123,137.899L-94.355,113.041L-51.123,88.184L-51.123,137.899ZM-250.355,88.184L-207.123,113.042L-250.355,137.899L-250.355,88.184ZM-301.478,49.714L-301.478,-3.026L-250.355,-32.421L-250.355,-91.211L-204.493,-117.581L-204.492,-58.791L-153.37,-88.186L-153.37,-35.446L-204.493,-6.051L-204.493,52.739L-250.355,79.109L-250.355,20.319L-301.478,49.714ZM-156,-92.724L-199.231,-67.866L-199.232,-117.581L-156,-92.724ZM-102.246,52.739L-148.109,79.109L-148.109,26.369L-102.246,-0.001L-102.246,52.739ZM-153.37,26.369L-153.37,79.109L-199.232,52.739L-199.232,-0.001L-153.37,26.369ZM-102.246,-117.581L-102.247,-67.866L-145.478,-92.724L-102.246,-117.581ZM-45.862,-35.446L-45.862,-94.236L-99.616,-125.143L-150.739,-95.748L-201.862,-125.143L-255.616,-94.236L-255.616,-35.446L-306.739,-6.051L-306.739,55.764L-255.616,85.159L-255.616,143.949L-201.862,174.857L-150.739,145.462L-99.616,174.857L-45.862,143.949L-45.862,85.159L5.261,55.764L5.261,-6.051L-45.862,-35.446Z" stroke="currentColor" fill="currentColor" /> </g> </g> </svg> Defold Engine**](/getting-started/defold-client)
- [**<svg enable-background="new 0 0 230 230" height="16" width="16" viewBox="0 0 230 230" xmlns="http://www.w3.org/2000/svg"><g style="fill:none;stroke:#000;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10" transform="matrix(.24008588 0 0 .24008588 -2.289055 -240.92061)"><path stroke="currentColor" fill="currentColor" d="m488.5212 1149.7881v-.1079l-443.5829-110.784h221.7874l221.7955 110.7839"/><path stroke="currentColor" fill="currentColor" d="m488.5212 1149.7881v-.1079l443.5992-110.7839h-221.8119l-221.7874 110.7839"/><path stroke="currentColor" fill="currentColor" d="m488.5212 1815.1521 443.5992 110.8938h-221.8119l-221.7874-111.0077"/><path stroke="currentColor" fill="currentColor" d="m488.5212 1815.1521-443.5829 110.8938h221.7874l221.7955-111.0077"/><path stroke="currentColor" fill="currentColor" d="m155.832 1482.469v-.126l-110.8937 443.7029v-221.7671l110.8937-221.9358"/><path stroke="currentColor" fill="currentColor" d="m155.832 1482.469v-.126l-110.8937-443.4468v221.7854l110.8937 221.6614"/><path stroke="currentColor" fill="currentColor" d="m821.2104 1482.469v-.126l110.8937-443.4468v221.7854l-110.8937 221.6614"/><path stroke="currentColor" fill="currentColor" d="m821.2104 1482.469 110.8937 443.5687v-221.7589l-110.8937-221.9379"/><path stroke="currentColor" fill="currentColor" d="m44.9383 1038.8962 443.5829 110.8918-332.6892 332.5062-110.8937-443.1721"/><path stroke="currentColor" fill="currentColor" d="m44.9383 1926.0459 110.8937-443.5748 332.6891 332.437-443.5828 110.6863"/><path stroke="currentColor" fill="currentColor" d="m932.1204 1038.8962-110.91 443.5546-332.6892-332.681 443.5992-110.6477"/><path stroke="currentColor" fill="currentColor" d="m932.1204 1926.0459-443.5992-110.8856 332.6892-332.6892 110.91 443.1233"/><path stroke="currentColor" fill="currentColor" d="m488.5212 1149.7881-332.6892 332.6809 332.6891 332.6831 332.6892-332.7013-332.6892-332.7726"/></g></svg> Haxe**](/getting-started/haxe-client)
- [**<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="16" height="16" viewBox="499 379 690 690" enable-background="new 0 0 1700.79004 1700.79004" xml:space="preserve"> <g id="bg"> <g> <g> <path fill-rule="evenodd" clip-rule="evenodd" stroke="currentColor" fill="currentColor" d="M850.39453,860.66992 c-50.35645,0-94.3252-27.35645-117.85254-68.02051l-80.03027,46.2041c-4.6543,2.68945-6.13086,8.71875-3.24805,13.25586 C691.50098,918.5957,765.7959,962.7168,850.39453,962.7168c88.12598,0,165.07129-47.875,206.24316-119.03613l-80.48633-46.46973 c-4.31445-2.49023-9.80273-1.20508-12.57129,2.93555C939.1748,836.64063,897.59082,860.66992,850.39453,860.66992 L850.39453,860.66992z M1136.7207,559.2959c4.61426-2.66309,6.11035-8.61914,3.3125-13.15137 c-59.91504-97.03027-167.22461-161.69434-289.63867-161.69434c-125.89355,0-235.81348,68.39258-294.63379,170.0498 l80.37695,46.40625c4.39844,2.53906,10.00195,1.14941,12.71094-3.14551 c42.16406-66.85156,116.66992-111.26367,201.5459-111.26367c88.12598,0,165.07129,47.87598,206.24316,119.03613 L1136.7207,559.2959z"/> <path fill-rule="evenodd" clip-rule="evenodd" stroke="currentColor" fill="currentColor" d="M850.39453,962.7168 c-84.59863,0-158.89355-44.12109-201.13086-110.60742c-2.87695-4.53027-1.40039-10.57031,3.24805-13.25586l80.03027-46.2041 c-11.58105-20.0166-18.20996-43.25488-18.20996-68.04199c0-74.78516,60.55762-136.0625,136.0625-136.0625 c47.19629,0,88.78027,24.0293,113.18555,60.52246c2.76465,4.13379,8.26367,5.42188,12.57129,2.93555l80.48633-46.46973 c-41.17188-71.16016-118.11719-119.03613-206.24316-119.03613c-84.87598,0-159.38184,44.41211-201.5459,111.26367 c-2.70605,4.29102-8.31836,5.68164-12.71094,3.14551L555.76074,554.5c-28.95215,50.04004-45.52344,108.13965-45.52344,170.10742 c0,186.96484,151.39453,340.1582,340.15723,340.1582c122.41406,0,229.72363-64.66406,289.63867-161.69531 c2.7959-4.52734,1.29492-10.49023-3.3125-13.15234l-80.08301-46.2373 C1015.46582,914.8418,938.52051,962.7168,850.39453,962.7168z"/> </g> <path fill-rule="evenodd" clip-rule="evenodd" stroke="currentColor" fill="currentColor" d="M1137.18457,761.19141v-73.16797l-63.36523,36.58398 L1137.18457,761.19141L1137.18457,761.19141z M1026.5752,708.24219l120.05859-69.31641 c12.56836-7.25586,28.3457,1.85254,28.3457,16.36621v138.63086c0,14.5127-15.77734,23.62207-28.3457,16.36621 l-120.05859-69.31641C1014.02734,733.72754,1014.02734,715.4873,1026.5752,708.24219z"/> </g> </g> <g id="logo"> </g> </svg> Construct 3**](/getting-started/construct3-client)
- [**Cocos Creator**](/getting-started/cocos-creator)

</div>

See [Unnoficial SDKs by the community](/community/#sdks-made-by-the-community)
for Unreal Engine, Godot and others.

## The Client Instance:

The `Client` instance is used to perform matchmaking calls, and later connect to one or many rooms.

=== "JavaScript"

    ``` typescript
    import Colyseus from "colyseus.js";
    // ...

    let client = new Colyseus.Client("ws://localhost:2567");
    ```

=== "C#"

    ``` csharp
    using Colyseus;
    // ...

    ColyseusClient client = new ColyseusClient("ws://localhost:2567");
    ```

=== "Lua"

    ``` lua
    local ColyseusClient = require("colyseus.client")
    // ...

    local client = ColyseusClient.new("ws://localhost:2567");
    ```

=== "Haxe"

    ``` haxe
    import io.colyseus.Client;
    // ...

    var client = new Client("ws://localhost:2567");
    ```

No connection with the server is established yet by creating a `Client` instance.

### Methods

#### `joinOrCreate (roomName: string, options: any)`

Join an existing room or create a new one, by provided `roomName` and `options`.

Locked or private rooms are ignored by this method.

=== "TypeScript"

    ``` typescript
    try {
      const room = await client.joinOrCreate("battle", {/* options */});
      console.log("joined successfully", room);

    } catch (e) {
      console.error("join error", e);
    }
    ```

=== "JavaScript"

    ``` typescript
    client.joinOrCreate("battle", {/* options */}).then(room => {
      console.log("joined successfully", room);
    }).catch(e => {
      console.error("join error", e);
    });
    ```

=== "C#"

    ``` csharp
    try {
      Room<YourStateClass> room = await client.JoinOrCreate<YourStateClass>("battle", /* Dictionary of options */);
      Debug.Log("joined successfully");

    } catch (ex) {
      Debug.Log("join error");
      Debug.Log(ex.Message);
    }
    ```

=== "Lua"

    ``` lua
    client:join_or_create("battle", {--[[options]]}, function(err, room)
      if (err ~= nil) then
        print("join error: " .. err)
        return
      end

      print("joined successfully")
    end)
    ```

=== "Haxe"

    ``` haxe
    client.joinOrCreate("battle", [/* options */], YourStateClass, function(err, room) {
      if (err != null) {
        trace("join error: " + err);
        return;
      }

      trace("joined successfully");
    });
    ```

=== "C++"

    ``` cpp
    client->joinOrCreate<YourStateClass>("battle", {/* options */}, [=](std::string err, Room<State>* room) {
      if (err != "") {
        std::cout << "join error: " << err << std::endl;
        return;
      }

      std::cout << "joined successfully" << std::endl;
    });
    ```

---

#### `create (roomName: string, options: any)`

Creates a new room by provided `roomName` and `options`.

=== "TypeScript"

    ``` typescript
    try {
      const room = await client.create("battle", {/* options */});
      console.log("joined successfully", room);

    } catch (e) {
      console.error("join error", e);
    }
    ```

=== "JavaScript"

    ``` typescript
    client.create("battle", {/* options */}).then(room => {
      console.log("joined successfully", room);
    }).catch(e => {
      console.error("join error", e);
    });
    ```

=== "C#"

    ``` csharp
    try {
      Room<YourStateClass> room = await client.Create<YourStateClass>("battle", /* Dictionary of options */);
      Debug.Log("joined successfully");

    } catch (ex) {
      Debug.Log("join error");
      Debug.Log(ex.Message);
    }
    ```

=== "Lua"

    ``` lua
    client:create("battle", {--[[options]]}, function(err, room)
      if (err ~= nil) then
        print("join error: " .. err)
        return
      end

      print("joined successfully")
    end)
    ```

=== "Haxe"

    ``` haxe
    client.create("battle", [/* options */], YourStateClass, function(err, room) {
      if (err != null) {
        trace("join error: " + err);
        return;
      }

      trace("joined successfully");
    });
    ```

=== "C++"

    ``` cpp
    client->create<YourStateClass>("battle", {/* options */}, [=](std::string err, Room<State>* room) {
      if (err != "") {
        std::cout << "join error: " << err << std::endl;
        return;
      }

      std::cout << "joined successfully" << std::endl;
    });
    ```

---

#### `join (roomName: string, options: any)`

Joins an existing room by provided `roomName` and `options`.

Locked or private rooms are ignored by this method.

=== "TypeScript"

    ``` typescript
    try {
      const room = await client.join("battle", {/* options */});
      console.log("joined successfully", room);

    } catch (e) {
      console.error("join error", e);
    }
    ```

=== "JavaScript"

    ``` typescript
    client.join("battle", {/* options */}).then(room => {
      console.log("joined successfully", room);
    }).catch(e => {
      console.error("join error", e);
    });
    ```

=== "C#"

    ``` csharp
    try {
      Room<YourStateClass> room = await client.Join<YourStateClass>("battle", /* Dictionary of options */);
      Debug.Log("joined successfully");

    } catch (ex) {
      Debug.Log("join error");
      Debug.Log(ex.Message);
    }
    ```

=== "Lua"

    ``` lua
    client:join("battle", {--[[options]]}, function(err, room)
      if (err ~= nil) then
        print("join error: " .. err)
        return
      end

      print("joined successfully")
    end)
    ```

=== "Haxe"

    ``` haxe
    client.join("battle", [/* options */], YourStateClass, function(err, room) {
      if (err != null) {
        trace("join error: " + err);
        return;
      }

      trace("joined successfully");
    });
    ```

=== "C++"

    ``` cpp
    client->join<YourStateClass>("battle", {/* options */}, [=](std::string err, Room<State>* room) {
      if (err != "") {
        std::cout << "join error: " << err << std::endl;
        return;
      }

      std::cout << "joined successfully" << std::endl;
    });
    ```

---

#### `joinById (roomId: string, options: any)`

Joins an existing room by its `roomId`. Private rooms can be joined by id.

=== "TypeScript"

    ``` typescript
    try {
      const room = await client.joinById("KRYAKzRo2", {/* options */});
      console.log("joined successfully", room);

    } catch (e) {
      console.error("join error", e);
    }
    ```

=== "JavaScript"

    ``` typescript
    client.joinById("KRYAKzRo2", {/* options */}).then(room => {
      console.log("joined successfully", room);
    }).catch(e => {
      console.error("join error", e);
    });
    ```

=== "C#"

    ``` csharp
    try {
      Room<YourStateClass> room = await client.JoinById<YourStateClass>("battle", /* Dictionary of options */);
      Debug.Log("joined successfully");

    } catch (ex) {
      Debug.Log("join error");
      Debug.Log(ex.Message);
    }
    ```

=== "Lua"

    ``` lua
    client:join_by_id("battle", {--[[options]]}, function(err, room)
      if (err ~= nil) then
        print("join error: " .. err)
        return
      end

      print("joined successfully")
    end)
    ```

=== "Haxe"

    ``` haxe
    client.joinById("battle", [/* options */], YourStateClass, function(err, room) {
      if (err != null) {
        trace("join error: " + err);
        return;
      }

      trace("joined successfully");
    });
    ```

=== "C++"

    ``` cpp
    client->joinById<YourStateClass>("battle", {/* options */}, [=](std::string err, Room<State>* room) {
      if (err != "") {
        std::cout << "join error: " << err << std::endl;
        return;
      }

      std::cout << "joined successfully" << std::endl;
    });
    ```

!!! Tip "Getting available `roomId`'s you can join"
    See [`getAvailableRooms()`](#getavailablerooms-roomname-string) to retrieve a list of rooms with their respective `roomId`'s available for joining, along with their metadata.

---

#### `reconnect (reconnectionToken)`

Reconnects the client back into a previously connected room.

- You must store/cache the `room.reconnectionToken` from an active room connection to be able to reconnect.
- To enable the reconnection of a particular client, the server-side needs to call [`.allowReconnection()`](/server/room#allowreconnection-client-seconds) for that client instance.

=== "TypeScript"

    ``` typescript
    try {
      const room = await client.reconnect(cachedReconnectionToken);
      console.log("joined successfully", room);

    } catch (e) {
      console.error("join error", e);
    }
    ```

=== "JavaScript"

    ``` typescript
    client.reconnect(cachedReconnectionToken).then(room => {
      console.log("joined successfully", room);
    }).catch(e => {
      console.error("join error", e);
    });
    ```

=== "C#"

    ``` csharp
    try {
      Room<YourStateClass> room = await client.Reconnect<YourStateClass>(cachedReconnectionToken);
      Debug.Log("joined successfully");

    } catch (ex) {
      Debug.Log("join error");
      Debug.Log(ex.Message);
    }
    ```

=== "Lua"

    ``` lua
    client:reconnect(cached_reconnection_token, function(err, room)
      if (err ~= nil) then
        print("join error: " .. err)
        return
      end

      print("joined successfully")
    end)
    ```

=== "Haxe"

    ``` haxe
    client.reconnect(cachedReconnectionToken, YourStateClass, function(err, room) {
      if (err != null) {
        trace("join error: " + err);
        return;
      }

      trace("joined successfully");
    });
    ```

<!-- ```haxe fct_label="C++"
client->reconnect<YourStateClass>(cachedReconnectionToken, [=](std::string err, Room<State>* room) {
  if (err != "") {
    std::cout << "join error: " << err << std::endl;
    return;
  }

  std::cout << "joined successfully" << std::endl;
});
``` -->

---

#### `getAvailableRooms (roomName?: string)`

Queries for all available rooms to connect.

- Locked and private rooms won't be listed.
- If the `roomName` parameter is ommitted, all rooms are going to be queried.

=== "JavaScript"

    ``` typescript
    client.getAvailableRooms("battle").then(rooms => {
      rooms.forEach((room) => {
        console.log(room.roomId);
        console.log(room.clients);
        console.log(room.maxClients);
        console.log(room.metadata);
      });
    }).catch(e => {
      console.error(e);
    });
    ```

=== "C#"

    ``` csharp
    try {
      var rooms = await client.GetAvailableRooms("battle");
      for (int i = 0; i < rooms.Length; i++) {
        Debug.Log(rooms[i].roomId);
        Debug.Log(rooms[i].clients);
        Debug.Log(rooms[i].maxClients);
        Debug.Log(rooms[i].metadata);
      }
    } catch (ex) {
      Debug.Log(ex.Message)
    }

    /**
     * Retrieving custom metadata
     */
    [Serializable]
    class Metadata
    {
        public string mode;
        public string name;
    }

    [Serializable]
    class CustomRoomAvailable : RoomAvailable
    {
        public Metadata metadata;
    }

    var rooms = await client.GetAvailableRooms<CustomRoomAvailable>("battle");
    Debug.Log(rooms[0].metadata.mode);
    ```

=== "Lua"

    ``` lua
    client:get_available_rooms("battle", function(err, rooms)
      if (err) then
        console.error(err);
        return
      end

      for i, room in pairs(rooms) do
        print(room.roomId)
        print(room.clients)
        print(room.maxClients)
        print(room.metadata)
      end
    end);
    ```

=== "Haxe"

    ``` haxe
    client.getAvailableRooms("battle", function(err, rooms) {
      if (err != null) {
        trace(err);
        return;
      }

      for (room in rooms) {
        trace(room.roomId);
        trace(room.clients);
        trace(room.maxClients);
        trace(room.metadata);
      }
    });
    ```

=== "C++"

    ``` cpp
    client.getAvailableRooms("battle", [=](std::string err, nlohmann::json rooms) {
      if (err != "") {
        std::cout << "error: " << err << std::endl;
        return;
      }

      // rooms
    });
    ```

---

#### `consumeSeatReservation (reservation)`

Join a room by manually consuming a "seat reservation".

=== "TypeScript"

    ``` typescript
    try {
      const room = await client.consumeSeatReservation(reservation);
      console.log("joined successfully", room);

    } catch (e) {
      console.error("join error", e);
    }
    ```

=== "JavaScript"

    ``` typescript
    client.consumeSeatReservation(reservation).then(room => {
      console.log("joined successfully", room);
    }).catch(e => {
      console.error("join error", e);
    });
    ```

=== "C#"

    ``` csharp
    try {
      Room<YourStateClass> room = await client.ConsumeSeatReservation<YourStateClass>(reservation);
      Debug.Log("joined successfully");

    } catch (ex) {
      Debug.Log("join error");
      Debug.Log(ex.Message);
    }
    ```

=== "Lua"

    ``` lua
    client:consume_seat_reservation(reservation, function(err, room)
      if (err ~= nil) then
        print("join error: " .. err)
        return
      end

      print("joined successfully")
    end)
    ```

=== "Haxe"

    ``` haxe
    client.consumeSeatReservation(reservation, YourStateClass, function(err, room) {
      if (err != null) {
        trace("join error: " + err);
        return;
      }

      trace("joined successfully");
    });
    ```

=== "C++"

    ``` cpp
    client->consumeSeatReservation<YourStateClass>(reservation, [=](std::string err, Room<State>* room) {
      if (err != "") {
        std::cout << "join error: " << err << std::endl;
        return;
      }

      std::cout << "joined successfully" << std::endl;
    });
    ```

!!! Tip "Advanced usage"
    See [Match-maker API](/server/matchmaker/#reserveseatforroom-options) to learn how to manually reserve a seat for a client within a room.

## The Room Instance:

### Properties

#### `state: any`

The current room's state. This variable is always synched with the latest
`state` from the server-side. To listen for updates on the whole state, see
[`onStateChange`](#onstatechange) event.

You may attach callbacks to specific structures inside your state. [See schema callbacks](/state/schema/#client-side).

---

#### `sessionId: string`

Unique identifier for the current connected client. This property matches the [`client.sessionId`](/server/client/#sessionid-string) from the server-side.

---

#### `id: string`

The unique idenfitier of the room. You can share this id with other clients in
order to allow them to connect directly to this room.

``` typescript
// get `roomId` from the query string
let roomId = location.href.match(/roomId=([a-zA-Z0-9\-_]+)/)[1];

// joining a room by its id
client.joinById(roomId).then(room => {
  // ...
});
```

---

#### `name: string`

Name of the room handler. Ex: `"battle"`.

---

### Methods

#### `send (type, message)`

Send a type of message to the room handler. Messages are encoded with MsgPack and can hold any JSON-serializable data structure.

=== "JavaScript"

    ``` typescript
    //
    // sending message with string type
    //
    room.send("move", { direction: "left"});

    //
    // sending message with number type
    //
    room.send(0, { direction: "left"});
    ```

=== "C#"

    ``` csharp
    //
    // sending message with string type
    //
    await room.Send("move", new { direction = "left" });

    //
    // sending message with number type
    //
    await room.Send(0, new { direction = "left" });
    ```

=== "Lua"

    ``` lua
    --
    -- sending message with string type
    --
    room:send("move", { direction = "left" })

    --
    -- sending message with number type
    --
    room:send(0, { direction = "left" })
    ```

=== "Haxe"

    ``` haxe
    //
    // sending message with string type
    //
    room.send("move", { direction: "left" });

    //
    // sending message with number type
    //
    room.send(0, { direction: "left" });
    ```

!!! tip "Use `Room#onMessage()` from the server-side to receive the messages"
    Check out [Server-side API &raquo; Room - onMessage()](/server/room/#onmessage-type-callback) section.

---

#### `sendBytes (type, bytes)`

Send a raw byte array as a message to the server. A byte array is an array of numbers from `0` to `255`.

This is useful if you'd like to manually encode a message, rather than the default encoding (MsgPack).

=== "JavaScript"

    ``` typescript
    //
    // sending message with number type
    //
    room.send(0, [ 172, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33 ]);


    //
    // sending message with string type
    //
    room.send("some-bytes", [ 172, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33 ]);
    ```

---

#### `leave (consented: boolean)`

Disconnect client from the room.

**Parameters**

- `consented`: Whether the act of leaving has been "consented" or not (Default is `true`)

=== "JavaScript"

    ``` typescript
    // consented leave
    room.leave();

    // unconsented leave
    room.leave(false);
    ```

=== "C#"

    ``` csharp
    // consented leave
    room.Leave();

    // unconsented leave
    room.Leave(false);
    ```

=== "Lua"

    ``` lua
    -- consented leave
    room:leave()

    -- unconsented leave
    room:leave(false)
    ```

=== "Haxe"

    ``` haxe
    // consented leave
    room.leave();

    // unconsented leave
    room.leave(false);
    ```

!!! Tip
    Use [Room#onLeave()](/server/room/#onleave-client-consented) to handle the disconnection from the server-side.

---

#### `removeAllListeners()`

Removes `onMessage`, `onStateChange`, `onLeave` and `onError` listeners.

---

### Events

#### onStateChange

!!! Tip "You may trigger callbacks for specific Schema structures"
    Check out the [State Handling » Schema » Client-side](/state/schema/#client-side) section for more details.

This event is triggered when the server updates its state.

=== "JavaScript"

    ``` typescript
    room.onStateChange.once((state) => {
      console.log("this is the first room state!", state);
    });

    room.onStateChange((state) => {
      console.log("the room state has been updated:", state);
    });
    ```

=== "C#"

    ``` csharp
    room.OnStateChange += (state, isFirstState) => {
      if (isFirstState) {
        Debug.Log ("this is the first room state!");
      }

      Debug.Log ("the room state has been updated");
    }
    ```

=== "Lua"

    ``` lua
    room:on("statechange", function(state)
      print("new state:", state)
    end)
    ```

=== "Haxe"

    ``` haxe
    room.onStateChange += function(state) {
      trace("new state:" + Std.string(state));
    };
    ```

=== "C++"

    ``` cpp
    room.onStateChange = [=](State>* state) {
      std::cout << "new state" << std::endl;
      // ...
    };
    ```

---

#### onMessage

This event is triggered when the server sends a message directly to the client, or via broadcast.

=== "JavaScript"

    ``` typescript
    room.onMessage("powerup", (message) => {
      console.log("message received from server");
      console.log(message);
    });
    ```

=== "C#"

    ``` csharp
    class PowerUpMessage {
      string kind;
    }

    room.OnMessage<PowerUpMessage>("powerup", (message) => {
      Debug.Log ("message received from server");
      Debug.Log(message);
    });
    ```

=== "Lua"

    ``` lua
    room:on_message("powerup", function(message)
      print("message received from server")
      print(message)
    end)
    ```

=== "Haxe"

    ``` haxe
    room.onMessage("powerup", function(message) {
      trace("message received from server");
      trace(Std.string(message));
    });
    ```

=== "C++"

    ``` cpp
    room.onMessage("powerup", [=](msgpack::object message) -> void {
        std::cout << "message received from server" << std::endl;
        std::cout << message << std::endl;
    });
    ```

!!! Tip
    To send a message from the server directly to the clients you'll need to use
    either [client.send()](/server/client/#sendtype-message) or
    [room.broadcast()](/server/room/#broadcast-type-message-options)

---

#### onLeave

This event is triggered when the client leave the room.

=== "JavaScript"

    ``` typescript
    room.onLeave((code) => {
      console.log("client left the room");
    });
    ```

=== "C#"

    ``` csharp
    room.OnLeave += (code) => {
      Debug.Log ("client left the room");
    }
    ```

=== "Lua"

    ``` lua
    room:on("leave", function()
      print("client left the room")
    end)
    ```

=== "Haxe"

    ``` haxe
    room.onLeave += function () {
      trace("client left the room");
    };
    ```

=== "C++"

    ``` cpp
    room.onLeave = [=]() -> void {
      std::cout << "client left the room" << std::endl;
    };
    ```

**Possible closing `code`s and their meaning:**

- `1000` - Regular socket shutdown
- Between `1001` and `1015` - Abnormal socket shutdown
- Between `4000` and `4999` - Custom socket close code (See [more details](/server/room/#table-of-websocket-close-codes))


---

#### onError

This event is triggered when some error occurs in the room handler.

=== "JavaScript"

    ``` typescript
    room.onError((code, message) => {
      console.log("oops, error ocurred:");
      console.log(message);
    });
    ```

=== "C#"

    ``` csharp
    room.OnError += (code, message) => {
      Debug.Log ("oops, error ocurred:");
      Debug.Log(message);
    }
    ```

=== "Lua"

    ``` lua
    room:on("error", function(code, message)
      print("oops, error ocurred:")
      print(message)
    end)
    ```

=== "Haxe"

    ``` haxe
    room.onError += function(code, message) {
      trace("oops, error ocurred:");
      trace(message);
    };
    ```

=== "C++"

    ``` cpp
    room.onError = [=] (int code, std::string message) => void {
      std::cout << "oops, error ocurred: " << message << std::endl;
    };
    ```
