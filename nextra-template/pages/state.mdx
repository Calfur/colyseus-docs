import { Cards, Steps, Tabs } from 'nextra/components'
import { CodeSquareIcon, FileBinaryIcon, EyeIcon, StarIcon } from '@primer/octicons-react'

## Guides

<Cards>
    <Cards.Card icon={<FileBinaryIcon/>} title="Schema Definition" href="/state/schema" />
    <Cards.Card icon={<CodeSquareIcon/>} title="Client-side Callbacks" href="/state/callbacks" />
    <Cards.Card icon={<EyeIcon/>} title="State View" href="/state/view" />
    <Cards.Card icon={<StarIcon/>} title="Best Practices" href="/state/best-practices" />
</Cards>

## Overview

Colyseus uses a schema-based approach to define the state of a room. The server is responsible for mutating the state, and the client listens for state changes to keep the user interface in sync.

- The room's state is defined using the `Schema` class from `@colyseus/schema`. Only the server can directly mutate the state.
- Clients send messages to the server to request state changes. Your room code processes these requests and updates the state.
- Colyseus optimizes performance and bandwidth by tracking property-level changes. Only the latest mutation of each property is queued and sent to clients during the [patchRate](/server/room/#patchrate) interval.
- On the client side, you listen for state changes to keep the user interface in sync

<Steps>
	### Server-side: Define your state structures

    Define your state structures by extending `Schema` class from `@colyseus/schema`:

    <Tabs items={["TypeScript", "JavaScript"]}>
        <Tabs.Tab>
        ```ts filename="src/rooms/MyState.ts"
        import { Schema, type } from "@colyseus/schema";

        export class Player extends Schema {
            @type("string") name: string;
            @type("number") x: number;
            @type("number") y: number;
        }

        export class MyState extends Schema {
            @type({ map: Player }) players = new MapSchema<Player>();
        }
        ```
        </Tabs.Tab>
        <Tabs.Tab>
        ```js filename="src/rooms/MyState.js"
        const schema = require("@colyseus/schema");

        exports.Player = schema.schema({
            name: "string",
            x: "number",
            y: "number",
        })

        exports.MyState = schema.schema({
            players: { map: Player }
        })
        ```
        </Tabs.Tab>
    </Tabs>


    ### Server-side: Assign and mutate the state

    Setting up the state in your room class, and mutating it when clients join or leave the room:

    <Tabs items={["TypeScript", "JavaScript"]}>
        <Tabs.Tab>
        ```ts {2,5,8,11} filename="src/rooms/MyRoom.ts"
        import { Room } from "colyseus";
        import { MyState, Player } from "./MyState";

        export class MyRoom extends Room<MyState> {
            state = new MyState();

            onJoin (client, options) {
                this.state.players.set(this.sessionId, new Player());
            }
            onLeave (client) {
                this.state.players.delete(this.sessionId);
            }
        }
        ```
        </Tabs.Tab>

        <Tabs.Tab>
        ```js {2,5,8,11} filename="src/rooms/MyRoom.js"
        const colyseus = require('colyseus');
        const MyState = require("./MyState");

        exports.MyRoom = class MyRoom extends colyseus.Room {
            state = new MyState.MyState();

            onJoin (client, options) {
                this.state.players.set(this.sessionId, new Player());
            }
            onLeave (client) {
                this.state.players.delete(this.sessionId);
            }
        }
        ```
        </Tabs.Tab>
    </Tabs>

    ### Client-side: Full state received on join

    Clients receive the full state when they join the room. Whenever a mutation occurs in the server-side, the state is automatically synchronized with all clients in the room.

    Below is an example of how to listen to player additions and removals on the client-side:

    ```js {9-11,14-16} copy filename="client.js"
    import { Client, getStateCallbacks } from 'colyseus.js';

    // ...
    const client = new Client('http://localhost:2567');
    const room = await client.joinOrCreate('my_room', {/* */});
    const $ = getStateCallbacks(room);

    // Listen to 'player' instance additions
    $(room.state).players.onAdd((player, sessionId) => {
        console.log('Player joined:', player);
    });

    // Listen to 'player' instance removals
    $(room.state).players.onRemove((player, sessionId) => {
        console.log('Player left:', player);
    });
    ```

    ### Client-side requests the server to mutate the state

    The client-side is not capable of mutating the state directly. Instead, it sends messages to the server to request state changes.

    ```js {4} filename="client.js"
    import { Client, getStateCallbacks } from 'colyseus.js';

    // ...
    room.send("set-position", { x: 16, y: 16 });
    ```

    The server-side processes these messages and updates the state accordingly:

    ```ts {6-11} filename="src/rooms/MyRoom.ts"
    // ...
    export class MyRoom extends Room<MyState> {
        state = new MyState();

        onCreate() {
            this.onMessage("set-position", (client, data) => {
                const player = this.state.players.get(client.sessionId);
                player.x = data.x;
                player.y = data.y;
            });
        }
        // ...
    ```

    ### Client listens to state changes

    The client listens to state changes at the instance level to keep the user interface in sync:

    <Tabs items={["Using .onChange() on instance", "Using .listen() on property"]}>
        <Tabs.Tab>
        ```js {10-12} filename="client.js"
        import { Client, getStateCallbacks } from 'colyseus.js';
        // ...
        const client = new Client('http://localhost:2567');
        const room = await client.joinOrCreate('my_room', {/* */});
        const $ = getStateCallbacks(room);

        // Listen to 'player' instance additions
        $(room.state).players.onAdd((player, sessionId) => {
            // Listening for any change on the player instance
            $(player).onChange(() => {
                console.log('Player changed:', player.x, player.y);
            });
        });
        ```
        </Tabs.Tab>

        <Tabs.Tab>
        ```js {10-15} filename="client.js"
        import { Client, getStateCallbacks } from 'colyseus.js';
        // ...
        const client = new Client('http://localhost:2567');
        const room = await client.joinOrCreate('my_room', {/* */});
        const $ = getStateCallbacks(room);

        // Listen to 'player' instance additions
        $(room.state).players.onAdd((player, sessionId) => {
            // Listen to direct property changes
            $(player).listen("x", (x, prevX) => {
                console.log('Player changed:', x, "from", prevX);
            });
            $(player).listen("y", (x, prevX) => {
                console.log('Player changed:', x, "from", prevX);
            });
        });
        ```
        </Tabs.Tab>
    </Tabs>
</Steps>

---

## How does it work, internally?



## Troubleshooting

### TypeScript Config

If you are using TypeScript, make sure to enable the `experimentalDecorators` and disable `useDefineForClassFields` in your `tsconfig.json` file.

```json filename="tsconfig.json"
{
    "compilerOptions": {
        "experimentalDecorators": true,
        "useDefineForClassFields": false
    }
}
```